! Copyright (C) 2012  ARPA-SIM <urpsim@smr.arpa.emr.it>
! authors:
! Davide Cesari <dcesari@arpa.emr.it>
! Paolo Patruno <ppatruno@arpa.emr.it>

! This program is free software; you can redistribute it and/or
! modify it under the terms of the GNU General Public License as
! published by the Free Software Foundation; either version 2 of 
! the License, or (at your option) any later version.

! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.

! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "config.h"

module volgrid6d_alchimia_class

USE volgrid6d_class
USE alchimia
USE grid_id_class
USE array_utilities
USE volgrid6d_var_class
USE vol7d_var_class

implicit NONE

interface make
   module procedure  make_vg6d
end interface

interface alchemy
   module procedure  alchemy_vg6d
end interface

private
public make, alchemy

contains

subroutine make_vg6d(mayvfn,mybin,mybout,vg6din,vg6dout,allvarcomputed)
type(fndsv),intent(inout) :: mayvfn
character(len=*),intent(in) :: mybin(:),mybout(:)
type(volgrid6d),intent(in) :: vg6din
type(volgrid6d),intent(out) :: vg6dout
TYPE(conv_func), pointer :: c_funcgb(:),c_funcbg(:)
logical, optional :: allvarcomputed !< do not delete in the output the gaid of all variables used for compute

integer :: i,j,nx,ny,nlevel,ntime,ntimerange,nvar,nvarin
integer :: ilevel,itime,itimerange,ivar,ivarin,ivarout
real,allocatable :: myin(:,:),myout(:,:)
character(len=10) :: newbout(mayvfn%nout+mayvfn%nin)
TYPE(vol7d_var),allocatable :: varv7d(:)
TYPE(volgrid6d_var),allocatable :: varvg6d(:)
TYPE(grid_id) :: gaid_template

nx=vg6din%griddim%dim%nx
ny=vg6din%griddim%dim%ny
nlevel=size(vg6din%level)
ntime=size(vg6din%time)
ntimerange=size(vg6din%timerange)

!we have to make a new volume with var required in input function plus var for output

!star with input variables
newbout=cmiss

do i=1, size(mayvfn%fnds)
  if (c_e(mayvfn%fnds(i))) then
    do j=1, size(mayvfn%fnds(i)%bin)
      if (c_e(mayvfn%fnds(i)%bin(j))) then
        if (index_c(mybin,mayvfn%fnds(i)%bin(j)) == 0)cycle 
        if (index_c(newbout,mayvfn%fnds(i)%bin(j)) <= 0) then
          newbout(index_c(newbout,cmiss)) = mayvfn%fnds(i)%bin(j)
        end if
      end if
    end do
  end if
end do

nvarin=count(c_e(newbout))

!add output variables
do i=1, size(mayvfn%fnds)
  if (c_e(mayvfn%fnds(i))) then
    do j=1, size(mayvfn%fnds(i)%bout)
      if (c_e(mayvfn%fnds(i)%bout(j))) then
        if (index_c(newbout,mayvfn%fnds(i)%bout(j)) <= 0) then
          newbout(index_c(newbout,cmiss)) = mayvfn%fnds(i)%bout(j)
        end if
      end if
    end do
  end if
end do


nvar=count(c_e(newbout))

allocate(myout(nx*ny,nvar))

! create output volume
call init(vg6dout, vg6din%griddim, vg6din%time_definition, categoryappend="generated by alchimia make")
!call volgrid6d_alloc(vg6dout, vg6din%griddim%dim, ntime, nlevel, ntimerange, nvar)
call volgrid6d_alloc(vg6dout, ntime=ntime, nlevel=nlevel, ntimerange=ntimerange, nvar=nvar)
call volgrid6d_alloc_vol(vg6dout,inivol=.true.,decode=.true.)

! allocate vector of conversion variables
allocate(varvg6d(nvar),source=volgrid6d_var_miss)
allocate (varv7d(nvar),source=vol7d_var_miss)

! now I copy the needed input variables from input volume to output 
do ivar=1, nvar
  ivarin  = index_c(mybin,newbout(ivar))
  ivarout = ivar

  if (ivarin == 0) then
    call l4f_log(L4F_debug,"variable to compute in make_vg6d: "//newbout(ivar))
    cycle
  end if

  varvg6d(ivarout)=vg6din%var(ivarin)
  call init(gaid_template)

  do ilevel=1,nlevel
    do itime=1,ntime
      do itimerange=1,ntimerange
        if ( .not. ASSOCIATED(vg6din%voldati)) then
!          call display(vg6din%gaid(ilevel,itime,itimerange,ivar),namespace="parameter")
          CALL grid_id_decode_data(vg6din%gaid(ilevel,itime,itimerange,ivarin),&
           vg6dout%voldati(:,:,ilevel,itime,itimerange,ivarout))
        else
          vg6dout%voldati(:,:,ilevel,itime,itimerange,ivarout)=vg6din%voldati(:,:,ilevel,itime,itimerange,ivarin)
        end if

        call copy (vg6din%gaid(ilevel,itime,itimerange,ivarin), vg6dout%gaid(ilevel,itime,itimerange,ivarout))
! save the first valid gaid for helping successive variable conversion
        IF (.NOT.c_e(gaid_template) .AND. &
         c_e(vg6din%gaid(ilevel,itime,itimerange,ivarin))) &
         gaid_template = vg6din%gaid(ilevel,itime,itimerange,ivarin)

!        print *,&
!         minval(vg6dout%voldati(:,:,ilevel,itime,itimerange,ivarout),&
!         c_e(vg6dout%voldati(:,:,ilevel,itime,itimerange,ivarout))),&
!         maxval(vg6dout%voldati(:,:,ilevel,itime,itimerange,ivarout),&
!         c_e(vg6dout%voldati(:,:,ilevel,itime,itimerange,ivarout)))

      end do
    end do
  end do
end do

CALL vargrib2varbufr(varvg6d(:nvarin), varv7d(:nvarin), c_funcgb)

do ivar = nvarin+1, nvar
  call init(varv7d(ivar),newbout(ivar))
end DO

CALL varbufr2vargrib(varv7d(nvarin+1:), varvg6d(nvarin+1:), c_funcbg, gaid_template)

vg6dout%time=vg6din%time
vg6dout%timerange=vg6din%timerange
vg6dout%level=vg6din%level
vg6dout%var=varvg6d

do ilevel=1,nlevel
  do itime=1,ntime
    do itimerange=1,ntimerange
      do i=size(mayvfn%fnds),1,-1

        if (c_e(mayvfn%fnds(i)) .and. .not. match(mayvfn%fnds(i)%name,"copy*") ) then
#ifdef DEBUG
          call l4f_log(L4F_DEBUG,"execute function: "//mayvfn%fnds(i)%name)
#endif
          myin=reshape(vg6dout%voldati(:,:,ilevel,itime,itimerange,:),(/nx*ny,nvar/))

          IF (ASSOCIATED(c_funcgb)) THEN
            DO ivar = 1, nvarin
                call compute(c_funcgb(ivar),myin(:,ivar))
            ENDDO
          else
            myin=rmiss
          ENDIF

          myout=myin

          call mayvfn%fnds(i)%fn(newbout,newbout,mayvfn%fnds(i)%bin,mayvfn%fnds(i)%bout,myin,myout)

          IF (ASSOCIATED(c_funcbg)) THEN
            DO ivar = 1, size(mayvfn%fnds(i)%bout)
              ivarout = index_c(newbout,mayvfn%fnds(i)%bout(ivar))
              if (ivarout > nvarin) call compute(c_funcbg(ivarout-nvarin),myout(:,ivarout))
            ENDDO
          else
            myout=rmiss
          ENDIF

          vg6dout%voldati(:,:,ilevel,itime,itimerange,:)=reshape(myout,(/nx,ny,nvar/))

          !search gaid to clone starting from input function variables
          do ivar=1, size(mayvfn%fnds(i)%bout)
            do j=1,size(mayvfn%fnds(i)%bin)
              ivarin  = index_c(mybin,mayvfn%fnds(i)%bin(j)) ! search in original fields
              if (ivarin > 0) ivarin = index_c(newbout,mybin(ivarin)) ! if found i get it from already cloned ones in output volume
              if (ivarin > 0) exit
            end do
            if (ivarin == 0) ivarin=firsttrue(c_e(vg6dout%gaid(ilevel,itime,itimerange,:))) ! if not found is enought from one present variables
            ivarout = index_c(newbout,mayvfn%fnds(i)%bout(ivar))

            if (ivarin > 0 .and. ivarout > 0 )then

              !print *, "DDD search",newbout(ivarout)
              !print *, "DDD index",index_c(mybout,newbout(ivarout))
              !if ( index_c(mybout,newbout(ivarout)) > 0)then

                call copy (vg6dout%gaid(ilevel,itime,itimerange,ivarin), vg6dout%gaid(ilevel,itime,itimerange,ivarout))

#ifdef HAVE_LIBGRIBAPI
                if (c_e(grid_id_get_gaid(vg6dout%gaid(ilevel,itime,itimerange,ivarout)))) then
                                !if (.not. match(mayvfn%fnds(i)%name,"copy*")) then
                                !print*,"force bit number to 24"
                  call grib_set(grid_id_get_gaid(vg6dout%gaid(ilevel,itime,itimerange,ivarout)),"bitsPerValue",24)
                end if
#endif
              !end if
            end if
          end do
        end if
      end do
    end do
  end do
end do


if (.not. optio_log(allvarcomputed)) then
  do ivar=1, nvar
    if (index_c(mybout,newbout(ivar)) <= 0) then
      do ilevel=1,nlevel
        do itime=1,ntime
          do itimerange=1,ntimerange
            call delete(vg6dout%gaid(ilevel,itime,itimerange,ivar))
          end do
        end do
      end do
    end if
  end do
end if

DEALLOCATE(c_funcgb)
DEALLOCATE(c_funcbg)
deallocate (varv7d,varvg6d)

end subroutine make_vg6d


integer function alchemy_vg6d(myin,vfn,mybout,myout,copy,vfnoracle,allvarcomputed)

character(len=*),intent(in) :: mybout(:)
type(fndsv),intent(in) :: vfn
type(volgrid6d),intent(in) :: myin(:)
type(volgrid6d),intent(out),pointer ::myout(:)
logical,intent(in),optional :: copy !< if .true. the copy functions are localy added to vfn (you can have input variable copyed to output)
type(fndsv),intent(out),optional :: vfnoracle
logical, optional :: allvarcomputed !< do not delete in the output the gaid of all variables used for compute

integer :: i,j,nvar
type(fndsv) :: myvfn,vfntmp
character(len=10), allocatable:: mybin(:)
TYPE(conv_func), pointer :: c_func(:)
TYPE(vol7d_var),allocatable :: varv7d(:)

alchemy_vg6d=0

allocate(myout(size(myin)))

do i=1,size(myin)

  nvar=size(myin(i)%var)
  allocate(varv7d(nvar))
  CALL vargrib2varbufr(myin(i)%var, varv7d, c_func)

  DEALLOCATE(c_func)

  !print *,"varv7d"
  !print *,varv7d

  mybin=varv7d(:)%btable
  deallocate(varv7d)

  vfntmp=vfn
  if (optio_log(copy)) call register_copy(vfntmp,mybin)


  do j=1,size(mybin)
    call l4f_log(L4F_INFO,"alchemy_vg6d: I have:   "//mybin(j))
  end do

  do j=1,size(mybout)
    call l4f_log(L4F_INFO,"alchemy_vg6d: To make:  "//mybout(j))
  end do

  if (.not. oracle(mybin,mybout,vfntmp,myvfn)) then
    call l4f_log(L4F_WARN,"alchemy_vg6d: I cannot make your request")
    alchemy_vg6d = 1
    if(.not. shoppinglist(mybout,vfntmp,myvfn,copy=optio_log(copy))) then
      call l4f_log(L4F_WARN,"shoppinglist: return error status")
      alchemy_vg6d = 2
    end if
    if (present(vfnoracle))vfnoracle=myvfn
    return
  end if

  if (present(vfnoracle))vfnoracle=myvfn
  
  !call display(myvfn)
  call l4f_log(L4F_INFO,"alchemy_vg6d: I need "//t2c(myvfn%nout)//" more variables")

  call make(myvfn,mybin,mybout,myin(i),myout(i), allvarcomputed)

  call delete(myvfn)
  call delete(vfntmp)

  !print *,"varvg6d"
  !print *,varvg6d

end do

end function alchemy_vg6d

end module volgrid6d_alchimia_class
