module volgrid6d_alchimia_class

USE volgrid6d_class
USE alchimia
USE grid_id_class
USE array_utilities
USE volgrid6d_var_class
USE vol7d_var_class

implicit NONE

interface make
   module procedure  make_vg6d
end interface

interface alchemy
   module procedure  alchemy_vg6d
end interface

private
public make, alchemy

contains

subroutine make_vg6d(mayvfn,mybin,mybout,vg6din,vg6dout)
type(fndsv),intent(inout) :: mayvfn
character(len=*),intent(in) :: mybin(:),mybout(:)
type(volgrid6d),intent(in) :: vg6din
type(volgrid6d),intent(out) :: vg6dout
integer :: i,nx,ny,nlevel,ntime,ntimerange,nvar,nvarin,ilevel,itime,itimerange,ivar,ivarin,ivarout
real,allocatable :: myin(:,:),myout(:,:)

nx=size(vg6din%voldati,1)
ny=size(vg6din%voldati,2)
nlevel=size(vg6din%voldati,3)
ntime=size(vg6din%voldati,4)
ntimerange=size(vg6din%voldati,5)
nvarin=size(mybin)
nvar=size(mybout)

allocate(myout(nx*ny,nvar))

call init(vg6dout, vg6din%griddim, vg6din%time_definition, categoryappend="generated by alchimia make")
call volgrid6d_alloc(vg6dout, vg6din%griddim%dim, ntime, nlevel, ntimerange, nvar)
call volgrid6d_alloc_vol(vg6dout,inivol=.true.)

vg6dout%time=vg6din%time
vg6dout%timerange=vg6din%timerange
vg6dout%level=vg6din%level

do i=size(mayvfn%fnds),1,-1
  if (c_e(mayvfn%fnds(i))) then
    do ilevel=1,nlevel
      do itime=1,ntime
        do itimerange=1,ntimerange
          myin=reshape(vg6din%voldati(:,:,ilevel,itime,itimerange,:),(/nx*ny,nvarin/))
          myout=rmiss
          call mayvfn%fnds(i)%fn(mybin,mybout,mayvfn%fnds(i)%bin,mayvfn%fnds(i)%bout,myin,myout)
          vg6dout%voldati(:,:,ilevel,itime,itimerange,:)=reshape(myout,(/nx,ny,nvar/))
          do ivar=1, size(mayvfn%fnds(i)%bout)
            ivarin  = index_c(mybin,mayvfn%fnds(i)%bin(1))
            ivarout = index_c(mybout,mayvfn%fnds(i)%bout(ivar))
            call copy (vg6din%gaid(ilevel,itime,itimerange,ivarin), vg6dout%gaid(ilevel,itime,itimerange,ivarout))

#ifdef HAVE_LIBGRIBAPI
            call grib_set(grid_id_get_gaid(vg6dout%gaid(ilevel,itime,itimerange,ivarout)),"bitsPerValue",24)
#endif

          end do
        end do
      end do
    end do
  end if
end do

end subroutine make_vg6d


subroutine alchemy_vg6d(myin,vfn,mybout,myout)

character(len=10),intent(in) :: mybout(:)
type(fndsv),intent(in) :: vfn
type(volgrid6d),intent(inout) :: myin(:)
type(volgrid6d),intent(out),pointer ::myout(:)


integer :: i,nvar,ivar
type(fndsv) :: myvfn
character(len=10), allocatable:: mybin(:)
TYPE(vol7d_var),allocatable :: varv7d(:)
TYPE(volgrid6d_var),allocatable :: varvg6d(:)
TYPE(conv_func), pointer :: c_func(:)


allocate(myout(size(myin)))

do i=1,size(myin)

  nvar=size(myin(i)%var)
  allocate(varv7d(nvar))
  CALL vargrib2varbufr(myin(i)%var, varv7d, c_func)

  print *,"varv7d"
  print *,varv7d

  IF (ASSOCIATED(c_func)) THEN
    DO ivar = 1, nvar
      myin(i)%voldati(:,:,:,:,:,ivar) = convert(c_func(ivar),myin(i)%voldati(:,:,:,:,:,ivar))
    ENDDO
  ENDIF
  DEALLOCATE(c_func)

  mybin=varv7d(:)%btable
  deallocate(varv7d)

  print *,"Ho a disposizione:  ",mybin
  print *,"Devo preparare:     ",mybout

  if (.not. oracle(mybin,mybout,vfn,myvfn)) then
    print*, " non riesco a fare ",mybout
    stop 3
  end if

  call display(myvfn)
  print *,"mi occorrono ",myvfn%nout," variabili in piu"

  call make(myvfn,mybin,mybout,myin(i),myout(i))

  nvar=size(mybout)
  allocate (varv7d(nvar))
  allocate(varvg6d(nvar))
  
  do ivar = 1, nvar
    call init(varv7d(ivar),mybout(ivar))
  end DO

  CALL varbufr2vargrib(varv7d, varvg6d, c_func)

  IF (ASSOCIATED(c_func)) THEN
    DO ivar = 1, nvar
      myout(i)%voldati(:,:,:,:,:,ivar) = convert(c_func(ivar),myout(i)%voldati(:,:,:,:,:,ivar))
    ENDDO
  ENDIF
  myout(i)%var=varvg6d
  DEALLOCATE(c_func)
  deallocate (varv7d)

  print *,"varvg6d"
  print *,varvg6d

  
end do

end subroutine alchemy_vg6d

end module volgrid6d_alchimia_class
