module volgrid6d_alchimia_class

USE volgrid6d_class
USE alchimia
USE grid_id_class
USE array_utilities
USE volgrid6d_var_class
USE vol7d_var_class

implicit NONE

interface make
   module procedure  make_vg6d
end interface

interface alchemy
   module procedure  alchemy_vg6d
end interface

private
public make, alchemy

contains

subroutine make_vg6d(mayvfn,mybin,mybout,vg6din,vg6dout,c_func)
type(fndsv),intent(inout) :: mayvfn
character(len=*),intent(in) :: mybin(:),mybout(:)
type(volgrid6d),intent(in) :: vg6din
type(volgrid6d),intent(out) :: vg6dout
TYPE(conv_func), pointer :: c_func(:)

integer :: i,j,nx,ny,nlevel,ntime,ntimerange,nvar,nvarin,ilevel,itime,itimerange,ivar,ivarin,ivarout
real,allocatable :: myin(:,:),myout(:,:),myminivol(:,:,:)
character(len=10) :: newbout(mayvfn%nout)
TYPE(vol7d_var),allocatable :: varv7d(:)
TYPE(volgrid6d_var),allocatable :: varvg6d(:)

nx=vg6din%griddim%dim%nx
ny=vg6din%griddim%dim%ny
nlevel=size(vg6din%level)
ntime=size(vg6din%time)
ntimerange=size(vg6din%timerange)
nvarin=size(mybin)
nvar=mayvfn%nout

newbout=cmiss
do i=1, size(mayvfn%fnds)
  if (c_e(mayvfn%fnds(i))) then
    do j=1, size(mayvfn%fnds(i)%bout)
      if (c_e(mayvfn%fnds(i)%bout(j))) then
        if (index_c(newbout,mayvfn%fnds(i)%bout(j)) <= 0) then
          newbout(index_c(newbout,cmiss)) = mayvfn%fnds(i)%bout(j)
        end if
      end if
    end do
  end if
end do

allocate(myout(nx*ny,nvar))

call init(vg6dout, vg6din%griddim, vg6din%time_definition, categoryappend="generated by alchimia make")
call volgrid6d_alloc(vg6dout, vg6din%griddim%dim, ntime, nlevel, ntimerange, nvar)
call volgrid6d_alloc_vol(vg6dout,inivol=.true.)

vg6dout%time=vg6din%time
vg6dout%timerange=vg6din%timerange
vg6dout%level=vg6din%level

do i=size(mayvfn%fnds),1,-1
  if (c_e(mayvfn%fnds(i))) then
    do ilevel=1,nlevel
      do itime=1,ntime
        do itimerange=1,ntimerange

          if ( .not. ASSOCIATED(vg6din%voldati)) then
            ALLOCATE(myminivol(vg6din%griddim%dim%nx,vg6din%griddim%dim%ny,nvarin))
            do ivar=1,nvarin
              CALL grid_id_decode_data(vg6din%gaid(ilevel,itime,itimerange,ivar), myminivol(:,:,ivar))
            end do
            myin=reshape(myminivol,(/nx*ny,nvarin/))
            deallocate(myminivol)
          else
            myin=reshape(vg6din%voldati(:,:,ilevel,itime,itimerange,:),(/nx*ny,nvarin/))
          end if

          IF (ASSOCIATED(c_func)) THEN
            DO ivar = 1, nvarin
                call compute(c_func(ivar),myin(:,ivar))
            ENDDO
          else
            myin=rmiss
          ENDIF

          myout=rmiss
          call mayvfn%fnds(i)%fn(mybin,newbout,mayvfn%fnds(i)%bin,mayvfn%fnds(i)%bout,myin,myout)
          vg6dout%voldati(:,:,ilevel,itime,itimerange,:)=reshape(myout,(/nx,ny,nvar/))
          do ivar=1, size(mayvfn%fnds(i)%bout)
            ivarin  = index_c(mybin,mayvfn%fnds(i)%bin(1))
            ivarout = index_c(newbout,mayvfn%fnds(i)%bout(ivar))
            call copy (vg6din%gaid(ilevel,itime,itimerange,ivarin), vg6dout%gaid(ilevel,itime,itimerange,ivarout))

#ifdef HAVE_LIBGRIBAPI
            if (.not. match(mayvfn%fnds(i)%name,"copy*")) then
              !print*,"force bit number to 24"
              call grib_set(grid_id_get_gaid(vg6dout%gaid(ilevel,itime,itimerange,ivarout)),"bitsPerValue",24)
            end if
#endif

          end do
        end do
      end do
    end do
  end if
end do

allocate (varv7d(nvar))
allocate(varvg6d(nvar))

do ivar = 1, nvar
  call init(varv7d(ivar),newbout(ivar))
end DO

DEALLOCATE(c_func)
CALL varbufr2vargrib(varv7d, varvg6d, c_func)

IF (ASSOCIATED(c_func)) THEN
  DO ivar = 1, nvar
    call compute(c_func(ivar),vg6dout%voldati(:,:,:,:,:,ivar))
  ENDDO
ENDIF
vg6dout%var=varvg6d
DEALLOCATE(c_func)
deallocate (varv7d)

end subroutine make_vg6d


integer function alchemy_vg6d(myin,vfn,mybout,myout,copy,vfnoracle)

character(len=10),intent(in) :: mybout(:)
type(fndsv),intent(in) :: vfn
type(volgrid6d),intent(in) :: myin(:)
type(volgrid6d),intent(out),pointer ::myout(:)
logical,intent(in),optional :: copy !< if .true. the copy functions are localy added to vfn (you can have input variable copyed to output)
type(fndsv),intent(out),optional :: vfnoracle

integer :: i,j,nvar,ivar
type(fndsv) :: myvfn,vfntmp
character(len=10), allocatable:: mybin(:)
TYPE(conv_func), pointer :: c_func(:)
TYPE(vol7d_var),allocatable :: varv7d(:)

alchemy_vg6d=0

allocate(myout(size(myin)))

do i=1,size(myin)

  nvar=size(myin(i)%var)
  allocate(varv7d(nvar))
  CALL vargrib2varbufr(myin(i)%var, varv7d, c_func)

  !print *,"varv7d"
  !print *,varv7d

  mybin=varv7d(:)%btable
  deallocate(varv7d)

  vfntmp=vfn
  if (optio_log(copy)) call register_copy(vfntmp,mybin)


  do j=1,size(mybin)
    call l4f_log(L4F_INFO,"alchemy_vg6d: I have:   "//mybin(j))
  end do

  do j=1,size(mybout)
    call l4f_log(L4F_INFO,"alchemy_vg6d: To make:  "//mybout(j))
  end do

  if (.not. oracle(mybin,mybout,vfntmp,myvfn)) then
    call l4f_log(L4F_WARN,"alchemy_vg6d: I cannot make your request")
    alchemy_vg6d = 1
    if(.not. shoppinglist(mybout,vfntmp,myvfn,copy=optio_log(copy))) then
      call l4f_log(L4F_WARN,"shoppinglist: return error status")
      alchemy_vg6d = 2
    end if
    if (present(vfnoracle))vfnoracle=myvfn
    return
  end if

  if (present(vfnoracle))vfnoracle=myvfn
  
  !call display(myvfn)
  call l4f_log(L4F_INFO,"alchemy_vg6d: I need "//t2c(myvfn%nout)//" more variables")

  call make(myvfn,mybin,mybout,myin(i),myout(i),c_func)

  call delete(myvfn)
  call delete(vfntmp)

  !print *,"varvg6d"
  !print *,varvg6d

end do

end function alchemy_vg6d

end module volgrid6d_alchimia_class
