module volgrid6d_alchimia_class

USE volgrid6d_class
USE alchimia
USE grid_id_class
USE array_utilities
USE volgrid6d_var_class
USE vol7d_var_class

implicit NONE

interface make
   module procedure  make_vg6d
end interface

interface alchemy
   module procedure  alchemy_vg6d
end interface

private
public make, alchemy

contains

subroutine make_vg6d(mayvfn,mybin,mybout,vg6din,vg6dout,c_func)
type(fndsv),intent(inout) :: mayvfn
character(len=*),intent(in) :: mybin(:),mybout(:)
type(volgrid6d),intent(in) :: vg6din
type(volgrid6d),intent(out) :: vg6dout
TYPE(conv_func), pointer :: c_func(:)

integer :: i,nx,ny,nlevel,ntime,ntimerange,nvar,nvarin,ilevel,itime,itimerange,ivar,ivarin,ivarout
real,allocatable :: myin(:,:),myout(:,:),myminivol(:,:,:)

nx=vg6din%griddim%dim%nx
ny=vg6din%griddim%dim%ny
nlevel=size(vg6din%level)
ntime=size(vg6din%time)
ntimerange=size(vg6din%timerange)
nvarin=size(mybin)
nvar=size(mybout)

allocate(myout(nx*ny,nvar))

call init(vg6dout, vg6din%griddim, vg6din%time_definition, categoryappend="generated by alchimia make")
call volgrid6d_alloc(vg6dout, vg6din%griddim%dim, ntime, nlevel, ntimerange, nvar)
call volgrid6d_alloc_vol(vg6dout,inivol=.true.)

vg6dout%time=vg6din%time
vg6dout%timerange=vg6din%timerange
vg6dout%level=vg6din%level

do i=size(mayvfn%fnds),1,-1
  if (c_e(mayvfn%fnds(i))) then
    do ilevel=1,nlevel
      do itime=1,ntime
        do itimerange=1,ntimerange

          if ( .not. ASSOCIATED(vg6din%voldati)) then
            ALLOCATE(myminivol(vg6din%griddim%dim%nx,vg6din%griddim%dim%ny,nvarin))
            do ivar=1,nvarin
              CALL grid_id_decode_data(vg6din%gaid(ilevel,itime,itimerange,ivar), myminivol(:,:,ivar))
            end do
            myin=reshape(myminivol,(/nx*ny,nvarin/))
            deallocate(myminivol)
          else
            myin=reshape(vg6din%voldati(:,:,ilevel,itime,itimerange,:),(/nx*ny,nvarin/))
          end if

          IF (ASSOCIATED(c_func)) THEN
            DO ivar = 1, nvarin
                call compute(c_func(ivar),myin(:,ivar))
            ENDDO
          else
            myin=rmiss
          ENDIF

          myout=rmiss
          call mayvfn%fnds(i)%fn(mybin,mybout,mayvfn%fnds(i)%bin,mayvfn%fnds(i)%bout,myin,myout)
          vg6dout%voldati(:,:,ilevel,itime,itimerange,:)=reshape(myout,(/nx,ny,nvar/))
          do ivar=1, size(mayvfn%fnds(i)%bout)
            ivarin  = index_c(mybin,mayvfn%fnds(i)%bin(1))
            ivarout = index_c(mybout,mayvfn%fnds(i)%bout(ivar))
            call copy (vg6din%gaid(ilevel,itime,itimerange,ivarin), vg6dout%gaid(ilevel,itime,itimerange,ivarout))

#ifdef HAVE_LIBGRIBAPI
            if (.not. match(mayvfn%fnds(i)%name,"copy*")) then
              !print*,"force bit number to 24"
              call grib_set(grid_id_get_gaid(vg6dout%gaid(ilevel,itime,itimerange,ivarout)),"bitsPerValue",24)
            end if
#endif

          end do
        end do
      end do
    end do
  end if
end do

end subroutine make_vg6d


integer function alchemy_vg6d(myin,vfn,mybout,myout,copy,vfnoracle)

character(len=10),intent(in) :: mybout(:)
type(fndsv),intent(in) :: vfn
type(volgrid6d),intent(in) :: myin(:)
type(volgrid6d),intent(out),pointer ::myout(:)
logical,intent(in),optional :: copy !< if .true. the copy functions are localy added to vfn (you can have input variable copyed to output)
type(fndsv),intent(out),optional,allocatable :: vfnoracle(:)

integer :: i,j,nvar,ivar
type(fndsv) :: myvfn,vfntmp
character(len=10), allocatable:: mybin(:)
TYPE(vol7d_var),allocatable :: varv7d(:)
TYPE(volgrid6d_var),allocatable :: varvg6d(:)
TYPE(conv_func), pointer :: c_func(:)

alchemy_vg6d=0

allocate(myout(size(myin)))
if (present(vfnoracle)) allocate (vfnoracle(size(myin)))

do i=1,size(myin)

  nvar=size(myin(i)%var)
  allocate(varv7d(nvar))
  CALL vargrib2varbufr(myin(i)%var, varv7d, c_func)

  !print *,"varv7d"
  !print *,varv7d

  mybin=varv7d(:)%btable
  deallocate(varv7d)

  vfntmp=vfn
  if (optio_log(copy)) call register_copy(vfntmp,mybin)


  do j=1,size(mybin)
    call l4f_log(L4F_INFO,"alchemy_vg6d: I have:   "//mybin(j))
  end do

  do j=1,size(mybout)
    call l4f_log(L4F_INFO,"alchemy_vg6d: To make:  "//mybout(j))
  end do

  if (.not. oracle(mybin,mybout,vfntmp,myvfn)) then
     call l4f_log(L4F_WARN,"alchemy_vg6d: I cannot make your request")
    alchemy_vg6d = 1
    return
  end if

  vfnoracle(i)=myvfn

  !call display(myvfn)
  call l4f_log(L4F_INFO,"alchemy_vg6d: I need "//t2c(myvfn%nout)//" more variables")

  call make(myvfn,mybin,mybout,myin(i),myout(i),c_func)

  nvar=size(mybout)
  allocate (varv7d(nvar))
  allocate(varvg6d(nvar))
  
  do ivar = 1, nvar
    call init(varv7d(ivar),mybout(ivar))
  end DO

  DEALLOCATE(c_func)
  CALL varbufr2vargrib(varv7d, varvg6d, c_func)

  IF (ASSOCIATED(c_func)) THEN
    DO ivar = 1, nvar
      call compute(c_func(ivar),myout(i)%voldati(:,:,:,:,:,ivar))
    ENDDO
  ENDIF
  myout(i)%var=varvg6d
  DEALLOCATE(c_func)
  deallocate (varv7d)

  call delete(myvfn)
  call delete(vfntmp)

  !print *,"varvg6d"
  !print *,varvg6d

end do

end function alchemy_vg6d

end module volgrid6d_alchimia_class
