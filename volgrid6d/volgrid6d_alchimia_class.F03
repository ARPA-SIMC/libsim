module volgrid6d_alchimia_class

USE volgrid6d_class
USE alchimia
USE grid_id_class
USE array_utilities
USE volgrid6d_var_class
USE vol7d_var_class

implicit NONE

interface make
   module procedure  make_vg6d
end interface

interface alchemy
   module procedure  alchemy_vg6d
end interface

private
public make, alchemy

contains

subroutine make_vg6d(mayvfn,mybin,mybout,vg6din,vg6dout)
type(fndsv),intent(inout) :: mayvfn
character(len=*),intent(in) :: mybin(:),mybout(:)
type(volgrid6d),intent(in) :: vg6din
type(volgrid6d),intent(out) :: vg6dout
TYPE(conv_func), pointer :: c_funcgb(:),c_funcbg(:)

integer :: i,j,nx,ny,nlevel,ntime,ntimerange,nvar,nvarin
integer :: ilevel,itime,itimerange,ivar,ivarin,ivarout
real,allocatable :: myin(:,:),myout(:,:)
character(len=10) :: newbout(mayvfn%nout+mayvfn%nin)
TYPE(vol7d_var),allocatable :: varv7d(:)
TYPE(volgrid6d_var),allocatable :: varvg6d(:)

nx=vg6din%griddim%dim%nx
ny=vg6din%griddim%dim%ny
nlevel=size(vg6din%level)
ntime=size(vg6din%time)
ntimerange=size(vg6din%timerange)


!we have to make a new volume with var required in input function plus var for output

!star with input variables
newbout=cmiss

do i=1, size(mayvfn%fnds)
  if (c_e(mayvfn%fnds(i))) then
    do j=1, size(mayvfn%fnds(i)%bin)
      if (c_e(mayvfn%fnds(i)%bin(j))) then
        if (index_c(mybin,mayvfn%fnds(i)%bin(j)) == 0)cycle 
        if (index_c(newbout,mayvfn%fnds(i)%bin(j)) <= 0) then
          newbout(index_c(newbout,cmiss)) = mayvfn%fnds(i)%bin(j)
        end if
      end if
    end do
  end if
end do

nvarin=count(c_e(newbout))

!add other required variables in input for function
do i=1, size(mayvfn%fnds)
  if (c_e(mayvfn%fnds(i))) then
    do j=1, size(mayvfn%fnds(i)%bin)
      if (c_e(mayvfn%fnds(i)%bin(j))) then
        if (index_c(newbout,mayvfn%fnds(i)%bin(j)) <= 0) then
          newbout(index_c(newbout,cmiss)) = mayvfn%fnds(i)%bin(j)
        end if
      end if
    end do
  end if
end do


!add output variables
do i=1, size(mayvfn%fnds)
  if (c_e(mayvfn%fnds(i))) then
    do j=1, size(mayvfn%fnds(i)%bout)
      if (c_e(mayvfn%fnds(i)%bout(j))) then
        if (index_c(newbout,mayvfn%fnds(i)%bout(j)) <= 0) then
          newbout(index_c(newbout,cmiss)) = mayvfn%fnds(i)%bout(j)
        end if
      end if
    end do
  end if
end do


nvar=count(c_e(newbout))

allocate(myout(nx*ny,nvar))

! create output volume
call init(vg6dout, vg6din%griddim, vg6din%time_definition, categoryappend="generated by alchimia make")
call volgrid6d_alloc(vg6dout, vg6din%griddim%dim, ntime, nlevel, ntimerange, nvar)
call volgrid6d_alloc_vol(vg6dout,inivol=.true.)

! allocate vector of conversion variables
allocate(varvg6d(nvar),source=volgrid6d_var_miss)
allocate (varv7d(nvar),source=vol7d_var_miss)

! now I copy the needed input variables from input volume to output 
do ivar=1, nvarin
  ivarin  = index_c(mybin,newbout(ivar))
  ivarout = ivar

  if (ivarin == 0) then
    call l4f_log(L4F_debug,"variable to compute in make_vg6d: "//newbout(ivar))
    cycle
  end if

  varvg6d(ivarout)=vg6din%var(ivarin)

  do ilevel=1,nlevel
    do itime=1,ntime
      do itimerange=1,ntimerange
        if ( .not. ASSOCIATED(vg6din%voldati)) then
          CALL grid_id_decode_data(vg6din%gaid(ilevel,itime,itimerange,ivar), vg6dout%voldati(:,:,ilevel,itime,itimerange,ivarout))
        else
          vg6dout%voldati(:,:,ilevel,itime,itimerange,ivarout)=vg6din%voldati(:,:,ilevel,itime,itimerange,ivarin)
        end if
        call copy (vg6din%gaid(ilevel,itime,itimerange,ivarin), vg6dout%gaid(ilevel,itime,itimerange,ivarout))
      end do
    end do
  end do
end do

CALL vargrib2varbufr(varvg6d(:nvarin), varv7d(:nvarin), c_funcgb)

do ivar = nvarin+1, nvar
  call init(varv7d(ivar),newbout(ivar))
end DO

CALL varbufr2vargrib(varv7d(nvarin+1:), varvg6d(nvarin+1:), c_funcbg)

vg6dout%time=vg6din%time
vg6dout%timerange=vg6din%timerange
vg6dout%level=vg6din%level
vg6dout%var=varvg6d

do ilevel=1,nlevel
  do itime=1,ntime
    do itimerange=1,ntimerange
      do i=size(mayvfn%fnds),1,-1
        if (c_e(mayvfn%fnds(i))) then

          myin=reshape(vg6dout%voldati(:,:,ilevel,itime,itimerange,:),(/nx*ny,nvar/))

          IF (ASSOCIATED(c_funcgb)) THEN
            DO ivar = 1, nvarin
                call compute(c_funcgb(ivar),myin(:,ivar))
            ENDDO
          else
            myin=rmiss
          ENDIF

          myout=rmiss

          call mayvfn%fnds(i)%fn(newbout,newbout,mayvfn%fnds(i)%bin,mayvfn%fnds(i)%bout,myin,myout)

          IF (ASSOCIATED(c_funcbg)) THEN
            DO ivar = 1, size(mayvfn%fnds(i)%bout)
              ivarout = index_c(newbout,mayvfn%fnds(i)%bout(ivar))
              if (ivarout > nvarin) call compute(c_funcbg(ivarout-nvarin),myout(:,ivarout))
            ENDDO
          else
            myout=rmiss
          ENDIF

          vg6dout%voldati(:,:,ilevel,itime,itimerange,:)=reshape(myout,(/nx,ny,nvar/))

          do ivar=1, size(mayvfn%fnds(i)%bout)
            do j=1,size(mayvfn%fnds(i)%bin)
              ivarin  = index_c(mybin,mayvfn%fnds(i)%bin(j))
              if (ivarin > 0) exit
            end do
            if (ivarin == 0) ivarin=firsttrue(c_e(vg6dout%gaid(ilevel,itime,itimerange,:)))
            ivarout = index_c(newbout,mayvfn%fnds(i)%bout(ivar))
            call copy (vg6dout%gaid(ilevel,itime,itimerange,ivarin), vg6dout%gaid(ilevel,itime,itimerange,ivarout))

#ifdef HAVE_LIBGRIBAPI
            if (.not. match(mayvfn%fnds(i)%name,"copy*")) then
              !print*,"force bit number to 24"
              call grib_set(grid_id_get_gaid(vg6dout%gaid(ilevel,itime,itimerange,ivarout)),"bitsPerValue",24)
            end if
#endif

          end do
        end if
      end do
    end do
  end do
end do


DEALLOCATE(c_funcgb)
DEALLOCATE(c_funcbg)
deallocate (varv7d,varvg6d)

end subroutine make_vg6d


integer function alchemy_vg6d(myin,vfn,mybout,myout,copy,vfnoracle)

character(len=10),intent(in) :: mybout(:)
type(fndsv),intent(in) :: vfn
type(volgrid6d),intent(in) :: myin(:)
type(volgrid6d),intent(out),pointer ::myout(:)
logical,intent(in),optional :: copy !< if .true. the copy functions are localy added to vfn (you can have input variable copyed to output)
type(fndsv),intent(out),optional :: vfnoracle

integer :: i,j,nvar
type(fndsv) :: myvfn,vfntmp
character(len=10), allocatable:: mybin(:)
TYPE(conv_func), pointer :: c_func(:)
TYPE(vol7d_var),allocatable :: varv7d(:)

alchemy_vg6d=0

allocate(myout(size(myin)))

do i=1,size(myin)

  nvar=size(myin(i)%var)
  allocate(varv7d(nvar))
  CALL vargrib2varbufr(myin(i)%var, varv7d, c_func)

  DEALLOCATE(c_func)

  !print *,"varv7d"
  !print *,varv7d

  mybin=varv7d(:)%btable
  deallocate(varv7d)

  vfntmp=vfn
  if (optio_log(copy)) call register_copy(vfntmp,mybin)


  do j=1,size(mybin)
    call l4f_log(L4F_INFO,"alchemy_vg6d: I have:   "//mybin(j))
  end do

  do j=1,size(mybout)
    call l4f_log(L4F_INFO,"alchemy_vg6d: To make:  "//mybout(j))
  end do

  if (.not. oracle(mybin,mybout,vfntmp,myvfn)) then
    call l4f_log(L4F_WARN,"alchemy_vg6d: I cannot make your request")
    alchemy_vg6d = 1
    if(.not. shoppinglist(mybout,vfntmp,myvfn,copy=optio_log(copy))) then
      call l4f_log(L4F_WARN,"shoppinglist: return error status")
      alchemy_vg6d = 2
    end if
    if (present(vfnoracle))vfnoracle=myvfn
    return
  end if

  if (present(vfnoracle))vfnoracle=myvfn
  
  call display(myvfn)
  call l4f_log(L4F_INFO,"alchemy_vg6d: I need "//t2c(myvfn%nout)//" more variables")

  call make(myvfn,mybin,mybout,myin(i),myout(i))

  call delete(myvfn)
  call delete(vfntmp)

  !print *,"varvg6d"
  !print *,varvg6d

end do

end function alchemy_vg6d

end module volgrid6d_alchimia_class
